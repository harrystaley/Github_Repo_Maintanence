
import os
import json
import re
from openai import OpenAI
from github import Github
from dotenv import load_dotenv

# --- Load Environment Variables ---
load_dotenv()

# --- GitHub and OpenAI Auth ---
GITHUB_TOKEN = os.getenv("GITHUB_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
OPENAI_MODEL = os.getenv("OPENAI_MODEL", "gpt-4-turbo")

if not GITHUB_TOKEN:
    raise ValueError("GITHUB_TOKEN not set in environment variables.")
if not OPENAI_API_KEY:
    raise ValueError("OPENAI_API_KEY not set in environment variables.")

# --- GitHub and OpenAI Clients ---
g = Github(GITHUB_TOKEN)
user = g.get_user()
client = OpenAI(api_key=OPENAI_API_KEY)

print(f"\nüîç Logged in as: {user.login}")

def generate_readme(repo_name, description, topics):
    """
    Generates a professional README.md file content using OpenAI's Chat API.

    Parameters:
        repo_name (str): The name of the GitHub repository.
        description (str): A brief description of the repository.
        topics (list): A list of relevant topics or tags for the repository.

    Returns:
        str: The generated README content in Markdown format.
    """
    prompt = f"""You are a helpful assistant who writes high-quality GitHub README.md files.

Repo Name: {repo_name}
Description: {description}
Topics: {', '.join(topics)}

Generate a professional README.md that includes:
1. A brief project overview including project structure if applicable.
2. Setup or installation instructions if applicable including dependencies.
3. Usage examples.
4. Contribution guidelines if applicable.
5. License section if applicable.
""".strip()

    response = client.chat.completions.create(
        model=OPENAI_MODEL,
        messages=[{"role": "user", "content": prompt}],
        temperature=0.5,
        max_tokens=1000
    )
    return response.choices[0].message.content.strip()

def should_update_readme(existing, new):
    """
    Compares the existing and generated README content to determine if an update is needed.

    Parameters:
        existing (str): Existing README content.
        new (str): Newly generated README content.

    Returns:
        bool: True if the new content is significantly different.
    """
    return existing.strip() != new.strip()

import argparse

def get_excluded_repos():
    """
    Builds a set of repositories to exclude from processing.
    """

    excluded = []
    for repo in user.get_repos():
        contents = repo.get_contents("")
        file_names = {content.name for content in contents if content.type == "file"}
        placeholder_files = {"README.md", ".gitignore", "LICENSE", ".gitattributes"}
        if file_names.issubset(placeholder_files):
            excluded.append(repo.name)

        if repo.archived or repo.fork or repo.name.endswith(".github.io") or repo.name == user.name:
            excluded.append(repo.name)
    print(f"üö´ Excluding {len(excluded)} repos: {', '.join(excluded)}")
    return excluded

def main():
    parser = argparse.ArgumentParser(description="Update READMEs with ChatGPT")
    parser.add_argument("--dry-run", action="store_true", help="Show changes without writing to GitHub")
    args = parser.parse_args()

    user = g.get_user()
    excluded = get_excluded_repos()


    for repo in user.get_repos():
        if repo.name in excluded:
            print(f"üö´ Skipping '{repo.name}' (archived, forked, private, personal page, or githup pages repo)")
            continue

        try:
            readme_file = repo.get_readme()
            if readme_file.name.lower() != "readme.md":
                print(f"‚è© Skipping special README file '{readme_file.name}' in '{repo.name}'")
                continue
            existing_readme = readme_file.decoded_content.decode()
        except:
            existing_readme = ""

        readme_content = generate_readme(
            repo_name=repo.name,
            description=repo.description or "",
            topics=repo.get_topics()
        )

        if not existing_readme:
            print(f"üìÑ Creating README.md for '{repo.name}'...")
            try:
                if args.dry_run:
                    print(f"üîé [Dry Run] Would create README.md for '{repo.name}'")
                else:
                    repo.create_file("README.md", "Add autogenerated README", readme_content)
                    print(f"‚úÖ README.md created for '{repo.name}'")
            except Exception as e:
                print(f"‚ö†Ô∏è Failed to create README.md for '{repo.name}': {e}")
        elif should_update_readme(existing_readme, readme_content):
            print(f"‚úèÔ∏è Updating README.md for '{repo.name}'...")
            try:
                if args.dry_run:
                    print(f"üîé [Dry Run] Would update README.md for '{repo.name}'")
                else:
                    repo.update_file(
                        "README.md",
                        "Update autogenerated README",
                        readme_content,
                        readme_file.sha
                    )
                    print(f"‚úÖ README.md updated for '{repo.name}'")
            except Exception as e:
                print(f"‚ö†Ô∏è Failed to update README.md for '{repo.name}': {e}")
        else:
            print(f"‚úÖ README.md for '{repo.name}' is already up to date.")

if __name__ == "__main__":
    main()
